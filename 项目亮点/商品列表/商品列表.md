

好久之前就像写这么一篇商品功能设计，这几天得空把坑给填了，给南友们多一个 "项目亮点" 的参考。

### 1.1 商品表设计

南哥先给出电商业务最基础的几个表设计。随着用户量的激增，肯定的是业务复杂性会逐日递增，你会发现简简单单的一个表，不知不觉多出了很多奇奇怪怪的字段。

（1）商品表

```sql

```

（2）商品分类表

```sql

```

（3）用户购物车表

```sql

```

（4）订单表

```sql

```

### 1.2 商品列表

商品列表在电商APP有多种形式，例如：热门商品列表、查询条件商品列表、用户推荐商品列表。

**（1）热门商品列表**

特别针对第一种形式，热门商品列表要重点加上缓存，毕竟该列表所有用户打开APP都需要显示出来，可以把该接口归类为高并发设计接口。

热门商品有一个特点，商品的更新速度快，可能某个商品半小时还在热门，下一秒突然不见。

这里我们采用Redis分布式缓存，后台配置热门商品时更新分布式缓存，而热门商品列表接口直接查询Redis，不把压力落到数据库。

```java
// 后台配置热门商品时更新分布式缓存，而热门商品列表接口直接查询Redis
```

另外需要把热门商品列表缓存到APP端，不至于每次返回主页面就调用一次接口查询。APP端缓存接口设置短些，例如1 分钟，毕竟上文有提到热门商品更新速度是比较快的！

**（2）查询条件商品列表**

用户的查询条件多种多样，我们可以把用户查询关键词通过埋点记录下来，要求运营给出热度最高的商品查询关键词。

针对热门关键词查询，把查询结果进行缓存。当然整个查询结果会很大，我们设置对前几页进行缓存。

**缓存放在哪？**

这里我们仍然放在Redis分布式缓存。有人可能会说放到后端本地缓存？MyBatis一级、二级缓存的坑或许他还没遇到，MyBatis一级缓存作用于SqlSession对象，二级缓存作用于Mapper对象。这造成了各个后端服务的本地缓存不同，每次查询的结果都不相同。

当然有些业务可以用到，例如阅读量这些用户不太在意的的数据可以用本地缓存。

```java
// 设置Redis分布式缓存
```

另一个问题，查询结果变化怎么办？

这里我们设置一个定时任务，每隔一段时间更新 "查询条件商品列表" 的缓存结果。

```java
// 定时任务更新缓存
```

### 1.3 商品详情

商品详情的特点是更新频率慢，另外用户的**操作习惯**是：会不断退出重进，反复浏览某个商品的详情页。

猜猜他们在干嘛，用户在反复对比不同商品，劝说自己究竟要买哪一个，毕竟强迫症大家都有的。

基于以上的用户行为、商品详情特点，我们可以把商品详情缓存到APP端。

### 1.4 商品下单

电商业务的订单记录表、商品下单接口是最重要的核心模块，毕竟这一块涉及到了业务赚钱的核心。

**（1）校验功能**

用户从APP端点击下单按钮，后端服务要走一套怎么样的流程？首先我们需要先进行校验。

1. 用户身份校验
2. 用户余额校验
3. 商品校验
4. 商品库存校验

**（2）防重复提交**

再者，对于下单接口需要添加防重复提交限制，这里可以有多种方案。举个例子，采用Redis分布式锁方案，Redis分布式锁的key设置与用户、商品id相关。

```
# Redis分布式锁的key
redis.log.bugy.{uid}.{product_id}
```

用户下单某一个商品，会获取Redis分布式锁。对于同一个商品，在前一个商品的逻辑没有处理完成时，不能进行下一次下单请求。

防重复提交的作用主要是防止用户误触，或者同一时间多个重复下单请求造成的数据异常。

**（3）事务控制**

对于整个下单的流程，包括库存的减少、用户扣费、订单表的创建都应该包含在同一个MySQL事务中，一旦流程中的任何一个逻辑出错，则进行回滚。

**（4）异步处理**

对于下单成功后的其他操作，例如下单成功信息通知用户等，可以使用任务队列的形式异步去执行，减少下单接口的耗时。

```java
// 用户下单接口
```



### 1.5 重点：秒杀抢购

我们可以把秒杀抢购看成是商品下单的特殊场景。秒杀抢购的并发量高，库存有限，且秒杀商品的页面会独立出来，不会和其他商品页面耦合在一起。

基于以上简单的梳理，我们可以这么设计来保证秒杀场景的稳定性。

**（1）秒杀页面静态化**

把秒杀商品页面设置为静态化，当用户刷新页面时，只需要从服务器获取基础后端数据进行填充。另外当用户点击秒杀按钮后，前端把按钮进行置灰，减少用户的请求。

**（2）下单限制**

很多程序员的初始设计会把所有请求都进入下单接口流程，**完全没必要！！！**

如果秒杀库存只有10，在下单接口前面，我们可以设置一个过滤拦截，只有前50个用户才会进入下单流程，拒绝其他用户的下单请求，其他用户甚至不需要进行下单的流程。

后续在由这50个用户抢夺这10个商品库存。

**（3）下单请求任务化**

把每一个下单请求都抽象为一个队列任务，任务一个个执行，减少系统的瞬时压力。

```java
// 秒杀下单接口
```

