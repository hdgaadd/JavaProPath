## 1. 可重入锁

> ***面试官：知道可重入锁有哪些吗?***

可重入意味着获取锁的粒度是**线程**而不是**调用**，如果大家知道这个概念，会更容易理解可重入锁的作用。

既然获取锁的粒度是线程，意味着线程自己是可以获取自己的内部锁的，而如果获取锁的粒度是调用则每次经过同步代码块都需要重新获取锁。

举个例子。线程A获取了某个对象锁，但在线程代码的流程中仍需再次获取该对象锁，此时线程A可以继续执行不需要重新再获取该对象锁。另外线程如果要使用**父类**的同步方法，由于可重入锁也无需再次获取锁。

在Java中，可重入锁主要有ReentrantLock、**synchronized**。

## 2. synchronized实现原理

> ***面试官：你先说说synchronized的实现原理?***

synchronized的实现是基于monitor的。任何对象都有一个**monitor**与之关联，当monitor被持有后，对象就会处于**锁定状态**。而在同步代码块的**开始位置**，在编译期间会被插入**monitorenter指令**。

当线程执行到monitorenter指令时，就会尝试获取**monitor**的所有权，如果获取得到则代表获得锁资源。

### 2.1 synchronized缺点

> ***面试官：那synchronized有什么缺点？***

在Java SE 1.6还没有对synchronized进行了各种优化前，很多人都会称synchronized为**重量级锁**，因为它对资源消耗是比较大的。

1. synchronized需要频繁的**获得锁、释放锁**，这会带来了不少性能消耗。

2. 另外没有获得锁的线程会被**操作系统**进行挂起阻塞、唤醒。而**唤醒操作**需要保存当前线程状态，切换到下一个线程，也就是进行**上下文切换**。上下文切换是很耗费资源的一种操作。


### 2.2 保存线程状态

> ***面试官：为什么上下文切换要保存当前线程状态？***

这就跟读英文课文时查字典一样，我们要先记住课文里的**页数**，查完字典好根据页数翻到英文课文原来的位置。

同理，CPU要保证可以**切换**到上一个线程的状态，就需要保存当前线程的状态。

### 2.3 锁升级

> ***面试官：可以怎么解决synchronized资源消耗吗？***

上文我有提到Java SE 1.6对synchronized进行了各种优化，具体的实现是给synchronized引入了**锁升级**的概念。synchronized锁一共有四种状态，级别从低到高依次是无锁、偏向锁、轻量级锁、重量级锁。

大家思考下，其实多线程环境有着各种不同的场景，同一个锁状态并不能够适应所有的业务场景。而这四种锁状态就是为了**适应各种不同场景**来使得线程并发的效率最高。

1. 没有任何线程访问同步代码块，此时synchronized是**无锁**状态。

2. 只有**一个线程**访问同步代码块的场景的话，会进入**偏向锁**状态。偏向锁顾名思义会**偏向访问它的线程**，使其加锁、解锁不需要额外的消耗。

3. 有**少量线程竞争**的场景的话，偏向锁会升级为**轻量级锁**。而轻量级采用**CAS操作**来获得锁，CAS操作不需要获得锁、释放锁，减少了像synchronized重量级锁带来的**上下文切换**资源消耗。

4. 轻量级锁通过CAS自旋来获得锁，如果自旋10次失败，为了减少CPU的消耗则锁会膨胀为**重量级锁**。此时synchronized重量级锁就回归到了悲观锁的状态，其他获取不到锁的都会进入阻塞状态。

### 2.4 锁升级优缺点

> ***面试官：它们都有什么优缺点呢？***

由于每个锁状态都有其不同的优缺点，也意味着有其不同的适应场景。

1. **偏向锁**的优点是加锁和解锁操作不需要额外的消耗；缺点是如果线程之间存在锁竞争，偏向锁会撤销，这也带来额外的撤销消耗；所以偏向锁适用的是只有一个线程的业务场景。
2. **轻量级锁**状态下，优点是线程不会阻塞，提高了程序执行效率；但如果始终获取不到锁的线程会进行**自旋**，而自旋动作是需要消耗**CPU**的；所以轻量级锁适用的是追求响应时间、同时同步代码块执行速度快的业务场景。
3. **重量级锁**的优点是不需要自旋消耗CPU；但缺点很明显，线程会阻塞、响应时间也慢；重量级锁更适用在同步代码块执行速度较长的业务场景。